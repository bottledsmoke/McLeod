# State = {

### Nodes: [

#### {Node}  

### ],

### EditingIndex: String
> 'id of node being edited'

# }

### Rules
- There must always be an empty node at the end of each row, and an empty node above and below each node of the longest row.
- If there is only one row, it is the longest row, so it will always have empty nodes above and below each of its nodes as well as an empty node at the end of the row.

      Node: {
        id: '18b580cf-f908-4255-8924-f28201f78287',
        text: The quick brown fox,
        links: {

        }
      }

      // Option 1: Array Position Determines Layout
      State: {
        Nodes: [       // All Nodes
          [null, null, null, null, null, null],
          [            // Row 1
            {          // Row 1, Node 1
              id:   '18b580cf-f908-4255-8924-f28201f78287',
              text: 'The quick brown fox',
              connections:
            },
            null,      // Empty Node
            null,      // Empty Node
            null,      // Empty Node
            {          // Row 1, Node 5
              id:   '14887133-7559-4a3b-80cd-f3fa3696dc56',
              text: 'Jumps over',
            },
            null,      // Row 1, Node 6 (Empty)
          ],
          [            // Row 2
            null,      // Row 2, Node 1 (Empty)
            null,      // Row 2, Node 2 (Empty)
            null,      // Row 2, Node 3 (Empty)
            {          // Row 2, Node 4
              id:   '367092bf-e2ba-4154-be05-e2979abe6426',
              text: 'the lazy dog',
            },
            null,      // Row 2, Node 5 (Empty)
            null,      // Row 2, Node 6 (Empty)
          ]
        ],
        EditingIndex: '367092bf-e2ba-4154-be05-e2979abe6426' // id of node being edited
      }

      // Option 2: Store Nodes in Object, Store Layout in Array.
      State: {
        Layout: [
          [
            null, '14887133-7559-4a3b-80cd-f3fa3696dc56', null
          ],
          [
            '18b580cf-f908-4255-8924-f28201f78287', null, null
          ],
          [
            null, '367092bf-e2ba-4154-be05-e2979abe6426', null
          ]
        ],
        Nodes: {
          '18b580cf-f908-4255-8924-f28201f78287': {
            text: 'The quick brown fox',
          },
          '14887133-7559-4a3b-80cd-f3fa3696dc56': {
            text: 'Jumps over',
          },
          '367092bf-e2ba-4154-be05-e2979abe6426': {
            text: 'The Lazy dog'
          }
        },
        EditingIndex: '367092bf-e2ba-4154-be05-e2979abe6426' // id of node being edited
      }

Maybe the array method is not the right way to go about this. Perhaps a tree structure does not play nicely with a linear array structure, especially one that needs to access multiple branches at once.

State = {
  initialNode: 'id of initial node' (String),
  nodes: { all nodes in k,v pairs as nodeId : Node} (Object),
  editingIndex: 'id of node being edited' (String),
}

Node = {
  id: 'string generated by node-uuid' (String),
  leaves: [Ids of Nodes branching off of this one] (Array),
  parent: {
    id: id of the parent (String, null if initial),
    blockedLeaves: [List of parent empty node indexes blocked by the inclusion of this node]
    },
  text: 'node text' (String)
}

Leaves Index Legend
  Top: 0,
  Upper Right: 1,
  Right: 2,
  Lower Right: 3,
  Bottom: 4

Leaves Possible Values ->
  '__id__' (String): nodeId,
  undefined: empty node,
  null: blocked node (does not render)

#Initial Rendering
  1. Render State.initialNode,
  2. Loop through leaves,
  3. If an ID is found, render the node and repeat 1-3
  4. If empty is found (value === undefined), render empty node,
  5. If null (value === null), do not render anything.
  6. Once loops return, play animation revealing the nodes one by one.
  7. Play animation that draws the connecting lines.

#Looping through leaves
Leaves should not be looped through in the standard 0 -> leaves.length fashion


#Adding a New Node
  1. onClick, get index from prop on the empty node and inflate it to a regular node. Autofocus on the input field. Clicking anywhere else will return the inflated node to its dot-size point appearance. If text has been entered into the field that was not submitted, notify the user, render the warning in a modal text box, and set the color of the dot-point empty node to yellow or red to reflect the level of warning / error the message represents.
  2. onSubmit, check the y coordinates of the leaves of the child.
  3. If the y coordinate of each child is within the radius + margin of any existing leaf of the parent, set the leaf to null on the child at that index.
  4. With all the data necessary, dispatch the addNode action with the index, the id of the parent node, and the leaves as the arg.
  5. Action creator delivers an action to the reducer with the new node object(leaves array, id, parentId), and the index.
  6. The reducer updates the leaf index of the parent using the parentId and index arguments.
  7. The new node is added to the nodes object using the generated id, leaves array, and the parentId args.
  8. Re-render the state.

#Removing a Node
  1. Click delete button or erase all text and submit.
  2. Confirm delete.
  3. Dispatch removeNode(nodeId, index) action.
  4. Get the data from the nodeId from the nodes object.
  5.





















Easiest way to solve blocked nodes problem : set empty node triggers at a lower z-index than nodes themselves, meaning they can never be clicked if they cannot be seen. This solves the Up-Left-Down-Right positions, but does not solve the diagonals.
